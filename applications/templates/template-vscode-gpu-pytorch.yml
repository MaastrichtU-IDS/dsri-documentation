---
kind: Template
apiVersion: template.openshift.io/v1
metadata:
  name: vscode-gpu-pytorch
  annotations:
    openshift.io/display-name: VisualStudio Code server
    description: |-
      Start VisualStudio Code server with PyTorch installed, and set up to be used with a GPU.

      ðŸ“‚ Use the /home/coder/project folder (workspace of the VSCode UI) to store your data in the existing persistent storage
      You can find the persistent storage in the DSRI web UI, go to Administrator view > Storage > Persistent Volume Claims

      Visit https://github.com/MaastrichtU-IDS/code-server for more details and to customize the image
    iconClass: icon-kubevirt
    tags: visualstudio,vscode,root,persistent
    openshift.io/provider-display-name: Research Computing Support, UM
    openshift.io/documentation-url: https://maastrichtu-ids.github.io/dsri-documentation/docs/deploy-vscode
    openshift.io/support-url: https://maastrichtu-ids.github.io/dsri-documentation/help
labels:
  template: vscode-gpu-pytorch

parameters:
  - name: APPLICATION_NAME
    displayName: Application name
    description: Must be without spaces (use -), and unique in the project.
    value: vscode-gpu-pytorch
    required: true
  - name: APPLICATION_IMAGE
    displayName: Docker image for the application
    description: See https://github.com/MaastrichtU-IDS/code-server for more details and to customize the image
    value: ghcr.io/maastrichtu-ids/code-server:gpu-pytorch
    required: true
  - name: STORAGE_SIZE
    displayName: Storage size
    description: Size of the storage used for the notebook workspace.
    value: 10Gi
    required: true
  - name: PASSWORD
    displayName: Password
    description: The password to access the VSCode application
    required: true

objects:
  - kind: ImageStream
    apiVersion: image.openshift.io/v1
    metadata:
      name: "${APPLICATION_NAME}"
      labels:
        app: "${APPLICATION_NAME}"
        template: vscode-gpu-pytorch
    spec:
      lookupPolicy:
        local: true
      tags:
        - name: latest
          from:
            kind: DockerImage
            name: ${APPLICATION_IMAGE}
          importPolicy:
            scheduled: false

  - kind: PersistentVolumeClaim
    apiVersion: v1
    metadata:
      name: "${APPLICATION_NAME}"
      labels:
        app: "${APPLICATION_NAME}"
    spec:
      accessModes:
        - ReadWriteMany
      resources:
        requests:
          storage: ${STORAGE_SIZE}
      storageClassName: ocs-storagecluster-cephfs

  - kind: Service
    apiVersion: v1
    metadata:
      name: "${APPLICATION_NAME}"
      labels:
        app: "${APPLICATION_NAME}"
    spec:
      selector:
        app: "${APPLICATION_NAME}" 
      ports:
        - name: "8080-tcp"
          protocol: TCP
          port: 8080
          targetPort: 8080

  - kind: Route
    apiVersion: route.openshift.io/v1
    metadata:
      name: "${APPLICATION_NAME}"
      labels:
        app: "${APPLICATION_NAME}"
    spec:
      to:
        kind: Service
        name: "${APPLICATION_NAME}"
      port:
        targetPort: "8080-tcp"
      tls:
        termination: edge
        insecureEdgeTerminationPolicy: Redirect

  - kind: Secret
    apiVersion: v1
    metadata:
      name: "${APPLICATION_NAME}"
      labels:
        app: "${APPLICATION_NAME}"
    stringData:
      application-password: "${PASSWORD}" 

  - kind: Deployment
    apiVersion: apps/v1
    metadata:
      name: "${APPLICATION_NAME}"
      labels:
        app: "${APPLICATION_NAME}"
    spec:
      replicas: 1
      strategy:
        type: Recreate
      selector:
        matchLabels:
          app: "${APPLICATION_NAME}" 
      template:
        metadata:
          annotations:
            io.kubernetes.cri-o.TrySkipVolumeSELinuxLabel: 'true'
          labels:
            app: "${APPLICATION_NAME}"
            deployment: "${APPLICATION_NAME}"
        spec:
          runtimeClassName: selinux
          serviceAccountName: anyuid
          automountServiceAccountToken: false
          volumes:
            - name: data 
              persistentVolumeClaim:
                claimName: "${APPLICATION_NAME}"
          containers:
            - name: "${APPLICATION_NAME}" 
              image: "${APPLICATION_IMAGE}" 
              imagePullPolicy: IfNotPresent
              workingDir: /home/coder/project
              ports:
                - containerPort: 8080
                  protocol: TCP
              volumeMounts:
                - name: data 
                  mountPath: "/home/coder/project" 
              env:
                - name: PASSWORD
                  valueFrom:
                    secretKeyRef:
                      name: "${APPLICATION_NAME}"
                      key: application-password 
              resources:
                requests:
                  cpu: "200m"
                  memory: "256Mi"
                limits:
                  cpu: '32'
                  memory: "200Gi"